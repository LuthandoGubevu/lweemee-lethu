'use client';

// This file is automatically generated. Do not modify it manually.
import { useState, useEffect, useRef } from 'react';
import {
  collection,
  query,
  onSnapshot,
  where,
  type CollectionReference,
  type Query as FsQuery,
} from 'firebase/firestore';
import { useFirestore } from '../provider';
import { errorEmitter } from '../error-emitter';
import { FirestorePermissionError } from '../errors';

type WhereClause = [string, '==', any];

type UseCollectionOptions = {
  where?: WhereClause;
};

type UseCollectionResult<T> = {
  data: (T & { id: string })[];
  loading: boolean;
  error: Error | null;
};

export function useCollection<T>(
  path: string | null | undefined,
  options?: UseCollectionOptions
): UseCollectionResult<T> {
  const firestore = useFirestore();

  const [data, setData] = useState<(T & { id: string })[]>([]);
  const [loading, setLoading] = useState<boolean>(!!path);
  const [error, setError] = useState<Error | null>(null);

  const queryRef = useRef<FsQuery | CollectionReference | null>(null);

  // Stable dependency for where clause
  const whereKey = options?.where ? JSON.stringify(options.where) : '';

  useEffect(() => {
    if (!firestore) return;

    // âœ… Allow caller to "skip" subscription entirely
    if (!path) {
      queryRef.current = null;
      setData([]);
      setError(null);
      setLoading(false);
      return;
    }

    // Reset state when path/options change
    setLoading(true);
    setError(null);

    try {
      let q: FsQuery | CollectionReference = collection(firestore, path);

      if (options?.where) {
        const [field, op, value] = options.where;
        q = query(q, where(field, op, value));
      }

      queryRef.current = q;

      const unsubscribe = onSnapshot(
        queryRef.current,
        (snapshot) => {
          const docs = snapshot.docs.map((d) => ({
            ...(d.data() as T),
            id: d.id,
          }));
          setData(docs);
          setLoading(false);
        },
        (err) => {
          console.error(err);

          const permissionError = new FirestorePermissionError({
            path,
            operation: 'list',
          });

          // Emit so your global toast system can catch it
          errorEmitter.emit('permission-error', permissionError);

          setError(permissionError);
          setLoading(false);
        }
      );

      return () => unsubscribe();
    } catch (e: any) {
      setError(e);
      setLoading(false);
    }
  }, [firestore, path, whereKey]);

  return { data, loading, error };
}
